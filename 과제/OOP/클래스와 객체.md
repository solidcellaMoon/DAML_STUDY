# 클래스와 객체

* [0405 수업 내용](#0405-수업-내용)



----

###### 0405 수업 내용

## OOP (Object-Oriented Programming)

<div align=center>

![oop](https://camo.githubusercontent.com/dcd5cc75151b02476cfdbf8269475ce6210f5ecc522e59a29b4c6c0427728d1d/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d687474702533412532462532466366696c6532372e75662e746973746f72792e636f6d253246696d61676525324631313446314534433530393543393237333244343336)

</div>

객체를 기반으로 프로그램을 작성한다.

* `객체`: 데이터 + 기능

  * 개념상의 의미: 어떤 일을 처리하기 위한 `데이터(변수/속성/필드)`와 `기능(메소드/함수)`을 하나로 묶은 것을 구체화한 단위
  * 문법상의 의미: **변수+메소드**

  

* **객체지향기법의 3R**

  * 가독성 (Readability)
  * 재사용성 (Reusability)
  * 신뢰성 (Reliability)



## 캡슐화: 객체지향 프로그래밍의 특징

* 약속되지 않은 부분, **보여줄 필요가 없는 부분**은 **감싸서 숨기는 것**
* 객체의 필드, 메소드를 하나로 묶고 **실제 구현 내용을 감추는 것**
* 외부 객체는 객체 내부 구조를 알지 못한다.
* 외부 객체는 객체가 노출해 제공하는 필드, 메소드만 이용할 수 있다.



### 필드, 메소드를 캡슐화로 보호하는 이유?

* 외부의 잘못된 사용을 막기 위해
* 캡슐화된 멤버를 노출시킬 지, 숨길 지 결정하기 위해



### 캡슐화 방법: 접근 제한자(Access Modifier)

| Type        | 특징                          |
| ----------- | ----------------------------- |
| public      | 모두가 접근 가능              |
| private (★) | 같은 클래스에서만 접근 가능   |
| protected   | 상속된 클래스에서만 접근 가능 |



## 상속: 객체 지향의 특성

<div align=center>

![상속트리](./images/0405상속트리.PNG)

</div>

**상속이란?**

> 공통 부분은 재사용하자!



`상속대상`: 상위 개체의 필드와 메소드 (생성자 제외)

> 즉 하위 객체는 상위 객체의 속성과 메소드를 **모두** 사용한다.



### 상속의 특징

- 하위 객체는 필요시 상위 개체의 메소드를 **재정의**할 수 있다.
- 새로운 개체를 정의할 때, 기존 개체를 **재사용**하는 용도로 사용한다.



**Is-A** 개념으로 상속을 이해할 수 있다.

- 예시: 새로운 클래스 A가 기존 클래스 B를 물려받았을 때
  - `Class A` **Is - A** `Class B`
- **A is B** 가 물리적/개념적으로 타당할 때에만 상속한다.
  - 고양이 다리는 4개, 책상 다리도 4개라 고양이가 책상을 상속하게 했다?? **NO**



### Java에서의 상속

`자식 클래스`가 `부모 클래스`의 `속성, 메소드` 들을 물려받고 기능을 확장한다.

이 때 속성과 메소드는 클래스의 `멤버`라고 칭한다.

- `부모 클래스`: super Class (상위 클래스)
- `자식 클래스`: sub Class (하위 클래스)
  - sub는 super class의 **멤버를 재사용**할 수 있다.
  - sub는 성질에 맞게 **새로운 특성을 추가**할 수 있다.



### 상속의 효과

<div align=center>

![상속효과](./images/0405상속효과.PNG)

</div>



* **반복된 코드의 중복을 줄인다.**
* **유지 보수의 편리성이 있다.**
* **객체의 `다형성`을 구현한다.**





---

