# Java 객체지향 프로그래밍 주요 개념 정리



## SOLID 원칙

#### 객체지향 설계원칙

1. **단일 책임 원칙 (Single Responsibility Principle)**
   - 모든 클래스는 각각 하나의 책임만 갖는다. (캡슐화와 관련)
2. **개방-폐쇄 원칙 (Open Closed Principle)**
   - 기존의 코드를 변경하지 않으면서(Closed) 확장에는 열려있는(Open) 설계
3. **리스코프 치황 원칙 (Liskov Substitution Principle)**
   - 자식 클래스는 부모 클래스를 대체할 수 있다.
   - 즉, 부모 클래스의 자리에 자식 클래스를 넣어도 코드가 의도대로 잘 작동해야 한다.
   - 자식 클래스는 부모 클래스를 재정의하지 않고 **확장만** 수행하도록 해야 이 원칙을 만족한다.
4. **인터페이스 분리 원칙 (Interface Segregation Principle)**
   - 자신이 사용하지 않는 인터페이스는 구현하지 않는다.
   - 하나의 일반적인 인터페이스보다, 여러개의 구체적인 인터페이스가 더 낫다.
5. **의존 역전 원칙 (Dependency Inversion Principle)**
   - 구체적인 클래스보단, 인터페이스나 추상 클래스와 관계를 맺으라.



## 다형성(Polymorphism)

- **메소드 오버로딩:** 메소드 이름은 같지만 **입력 파라미터**가 다르다 (return형은 관계없음)
- **메소드 오버라이딩:** 부모클래스에서 정의한 메소드를 자식클래스에서 특성에 맞게 재정의



## 캡슐화: 객체지향 프로그래밍의 특징

* 약속되지 않은 부분, **보여줄 필요가 없는 부분**은 **감싸서 숨기는 것**
* 객체의 필드, 메소드를 하나로 묶고 **실제 구현 내용을 감추는 것**
* 외부 객체는 객체 내부 구조를 알지 못한다.
* 외부 객체는 객체가 노출해 제공하는 필드, 메소드만 이용할 수 있다.



### 필드, 메소드를 캡슐화로 보호하는 이유?

* 외부의 잘못된 사용을 막기 위해
* 캡슐화된 멤버를 노출시킬 지, 숨길 지 결정하기 위해



### 캡슐화 방법: 접근 제한자(Access Modifier)

| Type      | 특징                                          |
| --------- | --------------------------------------------- |
| public    | 모두가 접근 가능                              |
| private   | 같은 클래스에서만 접근 가능                   |
| protected | 상속된 클래스에서만 접근 가능                 |
| **final** | 상수 선언할 때 사용, 선언 시 초기값 지정 필수 |

* **final**: 상수 필드는 실행 중 **값을 변경할 수 없다.**



## 싱글톤(Singleton) 패턴

* 하나의 프로그램 내에서 **단 하나만 생성되도록** 만든 객체

* static 멤버와 인스턴스 멤버를 활용한다.



### 싱글톤 생성 방법

1. **외부에서 new 연산자로 생성자를 호출할 수 없도록 막는다.**
2. **private 접근 제한자를 생성자 앞에 붙인다.**
3. 클래스 자신의 타입을 **정적 필드**로 선언한다.
   - `private` 를 통해 외부에서 필드 값 변경을 막는다.
4. **외부에서 호출할 수 있는 정적 메소드**인 `getInstance()`를 선언하여 접근한다.
   - 정적 필드에서 참조하고 있는 자신의 객체를 return 한다.





## 업캐스팅(UpCasting)과 다운캐스팅(DownCasting)

### 서브 클래스의 객체가 갖는 특징

- 슈퍼클래스의 멤버를 **모두** 갖는다.
- **슈퍼 클래스의 객체로 취급할 수 있다.**



### 업캐스팅(UpCasting)

- `자식클래스`의 객체를 `부모클래스` 타입으로 변환
- 이러한 경우 객체 내의 **슈퍼클래스의 멤버만** 접근할 수 있다.

```java
Sub s = new Sub();
Super super_s = s; // 업캐스팅, 자동타입변환
```



### 다운캐스팅(DownCasting)

- 업캐스팅한 `부모클래스` 객체를 `자식클래스` 타입으로 변환
- 개발자의 명시적 타입 변환이 필요

```java
Super super_s = new Sub(); // Up casting
Sub s = (Sub)super_s; // Down casting - 클래스 타입을 명시하기!
```



## 제네릭(Generic)

- 일반적인 코드를 작성하고, 이 코드를 **다양한 타입의 객체에 대해 재사용**하는 프로그래밍 기법
- 다양한 라이브러리 함수 활용에 도움됩니다.



### 제네릭 사용시 장점

- 실행시 런타임 타입 에러가 나는 것을 방지한다.
- 컴파일 시에 미리 타입을 강하게 체크한다.
- 타입변환 제거 가능!

```java
ArrayList<String> arr = new ArrayList<String>();
arr.add("Hi");
String now = arr.get(0);
```



---



# 이것만은 기억하자



```java
public class C extends B implements IA, IB, IC
```

이 코드의 구조도는 다음과 같다.

- `□C -> □B`
- `□C --> ○IA`
- `□C --> ○IB`
- `□C --> ○IC`



#### 이때 C 클래스가 갖는 메소드의 최소 개수는?

##### 정답: 5개

**풀이:**

```
C클래스 본인과, 상속받는 모든 클래스에 대한 생성자가 반드시 포함된다.
따라서 C(), B(), IA(), IB(), IC()가 C클래스가 필수로 갖는 최소한의 메소드이다.
```

