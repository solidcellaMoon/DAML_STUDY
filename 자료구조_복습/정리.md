## 1. 연결리스트

각 Node가 데이터를 갖고 포인터로 다음 노드나 이전 노드를 가리키는 자료구조.



```python
class Node :
    def __init__(self,data):
        self.data = data
        self.next = None

node1 = Node(10)
node2 = Node(20)
node3 = Node(30)

node1.next = node2
node2.next = node3

# n1 - n2 - n3 형식으로 연결된다.
```

## 2. 스택

LIFO 구조


```python
class Node :
    def __init__(self,data):
        self.data = data
        self.next = None

class Stack:
    def __init__(self):
        self.head = None
        
    def push(self,data):
        # 스택이 비어있을 때
        if self.head is None:
            self.head = Node(data)
        
        # 스택이 비어있지 않을 때
        else:
            new_node = Node(data)
            new_node.next = self.head
            self.head = new_node
            
    def pop(self):
        # 스택이 비었을 때
        if self.head is None:
            return None
        
        # 스택에 데이터가 없을 때
        else:
            popdata = self.head.data #head는 맨 위를 의미
            self.head = self.head.next
            return popdata
```


```python
list = [5,4,3,2,6,8]
s = Stack()

for i in list:
    s.push(i)
    
for _ in range(len(list)):
    print(s.pop())
    
print(s.pop())
```

    8
    6
    2
    3
    4
    5
    None
    

## 3. 큐
FIFO 구조


```python
class Node:
    def __init__(self,data):
        self.data = data
        self.next = None
        
# Queue
class Queue:
    def __init__(self):
        self.head = None
        self.tail = None
        
    # 비어있는지 확인
    def isEmpty(self):
        if self.head is None:
            return True
        else:
            return False
    
    #enqueue: ADD
    def enqueue(self,data):
        #비어있을 때
        if self.tail is None:
            self.head = self.tail = Node(data)
        
        #비어있지 않을 때
        else:
            #새로운 노드를 생성해 뒤에 붙이고
            self.tail.next = Node(data)
            #tail의 위치를 조정
            self.tail = self.tail.next
    
    
    #dequeue: REMOVE
    def dequeue(self):
        #empty
        if self.head is None:
            return None
        
        #not empty
        else:
            rm_data = self.head.data
            self.head = self.head.next
            return rm_data
```


```python
list = [5,4,3,2,6,8]
q = Queue()

for i in list:
    q.enqueue(i)
print('isEmpty?: ', q.isEmpty())

for _ in range(len(list)):
    print(q.dequeue())
print('isEmpty?: ', q.isEmpty())
```

    isEmpty?:  False
    5
    4
    3
    2
    6
    8
    isEmpty?:  True
    

## 4. 이진탐색트리

#### 시간복잡도
* 트리 형태: O(logN) 
* 최악의 경우: O(N) 트리가 일직선 형태



```python
class Node:
    def __init__(self,val):
        self.val = val
        self.left = None
        self.right = None
        
def insert(node,val):
    # root가 비어있다면 node를 root로 만든다.
    if node is None:
        return Node(val)
        
    #만약 root의 val값이 input보다 클 경우
    if val < node.val: #왼쪽에 넣는다
        node.left = insert(node.left,val)
            
    #만약 root의 val값이 input보다 작을 경우
    else: #오른쪽에 넣는다
        node.right = insert(node.right,val)
            
    #root값을 return
    return node

#작은 순서대로 출력하는 함수---
def inorder(root):
    if root is not None:
        inorder(root.left)
        print(root.val)
        inorder(root.right)
        
#최솟값 출력---
def min_val(node):
    #노드가 가장 왼쪽으로 가면 된다!!
    while node.left is not None:
        node = node.left
    return node.val
```


```python
list = [5,4,3,2,6,8]
root = None

for i in list:
    root = insert(root,i)

print('==inorder==')
inorder(root)

print('최솟값:',min_val(root))
```

    ==inorder==
    2
    3
    4
    5
    6
    8
    최솟값: 2
    
